use std::{sync::Arc, hash::{Hash, Hasher, self}, collections::hash_map::DefaultHasher, time::Instant};

use eframe::glow::Texture;
use egui::{ ScrollArea, ColorImage, TextureOptions, TextureId, pos2, Rect, Color32, Image, Vec2 };
use tidal_rs::model::{ self, Track, Album, Artist, SearchResult, SearchType };

use crate::{download::DownloadStatus, database::Song};

#[derive(Clone, PartialEq)]
pub enum Event {
    SearchResult(DrawableSearchResult),
    SongArray(DrawableSongArray)
}

type EventManager = (tokio::sync::mpsc::Sender<Event>, tokio::sync::mpsc::Receiver<Event>);

pub trait Drawable<T> {
    async fn get_texture_from_url(
        item: &T,
        ctx: &egui::Context
    ) -> (egui::TextureHandle, egui::TextureId) {
        let cover = Self::fetch_cover(&item).await.unwrap();
        let raw_image = load_image_from_memory(&cover).unwrap();
        let texture = ctx.load_texture(
            Self::get_item_name(&item),
            raw_image,
            TextureOptions::default()
        );
        let texture_id = TextureId::from(&texture);

        (texture, texture_id)
    }

    async fn fetch_cover(item: &T) -> Result<Vec<u8>, tidal_rs::error::Error> {
        let url = Self::get_url(item);
        let bytes = reqwest
            ::get(&url).await
            .map_err(|e| tidal_rs::error::Error::Reqwest(e))?
            .bytes().await
            .map_err(|_| tidal_rs::error::Error::ParseError)?;
        Ok(bytes.to_vec())
    }

    fn get_item(&self) -> T;
    fn get_item_name(item: &T) -> String;
    fn get_url(item: &T) -> String;

    fn get_title(&self) -> String {
        Self::get_item_name(&self.get_item())
    }

    fn get_texture(&self) -> &egui::TextureHandle;
}

#[derive(Clone, PartialEq)]
pub struct DrawableTrack {
    track: Track,
    texture: egui::TextureHandle,
    texture_id: egui::TextureId,
}

#[derive(Clone, PartialEq)]
pub struct DrawableAlbum {
    album: model::Album,
    texture: egui::TextureHandle,
    texture_id: egui::TextureId,
}

#[derive(Clone, PartialEq)]
pub struct DrawableArtist {
    artist: model::Artist,
    texture: egui::TextureHandle,
    texture_id: egui::TextureId,
}

impl Drawable<Track> for DrawableTrack {
    fn get_item(&self) -> Track {
        self.track.clone()
    }

    fn get_item_name(item: &Track) -> String {
        item.title.clone()
    }

    fn get_url(item: &Track) -> String {
        if item.album.is_some() {
            format!(
                "{}/{}/80x80.jpg",
                "https://resources.tidal.com/images",
                item.album.as_ref().unwrap().cover.replace("-", "/")
            )
        } else {
            "https://media.discordapp.net/attachments/1146883003402952797/1196115483477413928/281202_folder_512x512.png?ex=65b6745a&is=65a3ff5a&hm=e6121be910cad9e16938bb69d6a214a3a1c40e525af647ef1cf1efa2146d805a&=&format=webp&quality=lossless&width=80&height=80".to_string()
        }
    }

    fn get_texture(&self) -> &egui::TextureHandle {
        &self.texture
    }

    fn get_title(&self) -> String {
        format!("{} - {}", self.track.get_artist().name, self.track.title)
    }
}

impl Drawable<Album> for DrawableAlbum {
    fn get_item(&self) -> Album {
        self.album.clone()
    }

    fn get_item_name(item: &Album) -> String {
        item.title.clone()
    }

    fn get_url(item: &Album) -> String {
        format!(
            "{}/{}/80x80.jpg",
            "https://resources.tidal.com/images",
            item.cover.replace("-", "/")
        )
    }

    fn get_texture(&self) -> &egui::TextureHandle {
        &self.texture
    }
}

impl Drawable<Artist> for DrawableArtist {
    fn get_item(&self) -> Artist {
        self.artist.clone()
    }

    fn get_item_name(item: &Artist) -> String {
        item.name.clone()
    }

    fn get_url(item: &Artist) -> String {
        if item.picture.is_some() {
            format!(
                "{}/{}/320x320.jpg",
                "https://resources.tidal.com/images",
                item.picture.as_ref().unwrap().replace("-", "/")
            )
        } else {
            "https://media.discordapp.net/attachments/1146883003402952797/1196115483477413928/281202_folder_512x512.png?ex=65b6745a&is=65a3ff5a&hm=e6121be910cad9e16938bb69d6a214a3a1c40e525af647ef1cf1efa2146d805a&=&format=webp&quality=lossless&width=80&height=80".to_string()
        }
    }

    fn get_texture(&self) -> &egui::TextureHandle {
        &self.texture
    }
}

impl DrawableTrack {
    pub async fn from_track(ctx: &egui::Context, track: Track) -> Self {
        let (texture, texture_id) = Self::get_texture_from_url(&track, ctx).await;
        Self {
            track,
            texture,
            texture_id,
        }
    }
}

impl DrawableAlbum {
    pub async fn from_album(ctx: &egui::Context, album: Album) -> Self {
        let (texture, texture_id) = Self::get_texture_from_url(&album, ctx).await;
        Self {
            album,
            texture,
            texture_id,
        }
    }
}

impl DrawableArtist {
    pub async fn from_artist(ctx: &egui::Context, artist: model::Artist) -> Self {
        let (texture, texture_id) = Self::get_texture_from_url(&artist, ctx).await;
        Self {
            artist,
            texture,
            texture_id,
        }
    }
}

#[derive(Clone, PartialEq)]
pub struct DrawableSearchResult {
    pub track: Vec<DrawableTrack>,
    pub album: Vec<DrawableAlbum>,
    pub artist: Vec<DrawableArtist>,
}

impl DrawableSearchResult {
    pub fn new() -> Self {
        Self {
            track: Vec::new(),
            album: Vec::new(),
            artist: Vec::new(),
        }
    }

    pub fn is_empty(&self) -> bool {
        self.track.is_empty() && self.album.is_empty() && self.artist.is_empty()
    }

    pub async fn from_search_result(ctx: &egui::Context, item: &SearchResult) -> Self {
        let mut track: Vec<DrawableTrack> = Vec::with_capacity(item.tracks.len());
        let mut album: Vec<DrawableAlbum> = Vec::with_capacity(item.albums.len());
        let mut artist: Vec<DrawableArtist> = Vec::with_capacity(item.artists.len());

        for track_item in item.tracks.iter() {
            track.push(DrawableTrack::from_track(ctx, track_item.clone()).await);
        }

        for album_item in item.albums.iter() {
            album.push(DrawableAlbum::from_album(ctx, album_item.clone()).await);
        }

        for artist_item in item.artists.iter() {
            artist.push(DrawableArtist::from_artist(ctx, artist_item.clone()).await);
        }

        Self {
            track,
            album,
            artist,
        }
    }
}

#[derive(Clone, PartialEq)]
struct DrawableSong {
    song: Song,
    texture: egui::TextureHandle,
    texture_id: egui::TextureId,
}

impl Drawable<Song> for DrawableSong {
    fn get_item(&self) -> Song {
        self.song.clone()
    }

    fn get_item_name(item: &Song) -> String {
        item.title.clone()
    }

    fn get_url(item: &Song) -> String {
        if item.tidal_track.is_some() {
            DrawableTrack::get_url(&item.tidal_track.as_ref().unwrap())
        } else {
            "https://media.discordapp.net/attachments/1146883003402952797/1196115483477413928/281202_folder_512x512.png?ex=65b6745a&is=65a3ff5a&hm=e6121be910cad9e16938bb69d6a214a3a1c40e525af647ef1cf1efa2146d805a&=&format=webp&quality=lossless&width=80&height=80".to_string()
        }
    }

    fn get_texture(&self) -> &egui::TextureHandle {
        &self.texture
    }
}

impl DrawableSong {
    pub async fn from_song(ctx: &egui::Context, song: Song) -> Self {
        let (texture, texture_id) = Self::get_texture_from_url(&song, ctx).await;
        Self {
            song,
            texture,
            texture_id,
        }
    }
}

#[derive(Clone, PartialEq)]
pub struct DrawableSongArray {
    songs: Vec<DrawableSong>,
    hash: u64,
    created_at: Instant
}

impl DrawableSongArray {
    pub fn new() -> Self {
        Self {
            songs: Vec::new(),
            hash: 0,
            created_at: Instant::now()
        }
    }

    pub async fn from_song_array(ctx: &egui::Context, songs: Vec<Song>) -> Self {
        let mut drawable_songs = Vec::with_capacity(songs.len());

        let mut hasher = DefaultHasher::new();
        songs.hash(&mut hasher);

        for song in songs {
            drawable_songs.push(DrawableSong::from_song(ctx, song).await);
        }

        Self {
            songs: drawable_songs,
            hash: hasher.finish(),
            created_at: Instant::now()
        }
    }
}

pub struct GuiInput {
    pub search_query: String,
    pub event_manager: EventManager,
    pub search_results: DrawableSearchResult,
    pub search_type: SearchType,
    pub song_array: DrawableSongArray,
    pub requested_song_array:bool
}

impl Default for GuiInput {
    fn default() -> Self {
        Self {
            search_query: String::new(),
            event_manager: tokio::sync::mpsc::channel(20),
            search_results: DrawableSearchResult::new(),
            search_type: SearchType::Track,
            song_array: DrawableSongArray::new(),
            requested_song_array: false
        }
    }
}

fn load_image_from_memory(image_data: &[u8]) -> Result<ColorImage, image::ImageError> {
    let image = image::load_from_memory(image_data)?;
    let size = [image.width() as _, image.height() as _];
    let image_buffer = image.to_rgba8();
    let pixels = image_buffer.as_flat_samples();
    Ok(ColorImage::from_rgba_unmultiplied(size, pixels.as_slice()))
}

impl eframe::App for crate::app::App {
    fn update(&mut self, ctx: &egui::Context, frame: &mut eframe::Frame) {
        if let Ok(event) = self.gui_settings.event_manager.1.try_recv() {
            match event {
                Event::SearchResult(tracks) => {
                    self.gui_settings.search_results = tracks;
                },
                Event::SongArray(song_array) => {
                    println!("Received new song array");
                    self.gui_settings.requested_song_array = false;
                    self.gui_settings.song_array = song_array;
                }
            }
        }

        egui::CentralPanel::default().show(ctx, |ui| {
            ui.heading("Localfy");

            let downloads = self.app.download_manager.get_downloads();

            ui.label(format!("{} downloads", downloads.len()));
            downloads.iter().for_each(|x| {
                //display speed, progress, eta, status, title

                if x.status == DownloadStatus::Downloading {
                    ui.label(
                        format!(
                            "{} - {} - {}% ({}kbps)",
                            x.download.track.title,
                            x.download.track.get_artist().name,
                            (x.progress * 100.0).round(),
                            x.speed.to_kbps()
                        )
                    );
                } else {
                    ui.label(
                        format!(
                            "{} - {} - {}% ({})",
                            x.download.track.title,
                            x.download.track.get_artist().name,
                            (x.progress * 100.0).round(),
                            x.status.to_string()
                        )
                    );
                }
            });

            if let Some(authorization) = self.app.tidal_client.authorization() {
                ui.label(format!("Logged in as {}", authorization.user.user_id));

                let inner = ui.horizontal(|ui| {
                    ui.label("Search for a song (downloader) : ");
                    ui.text_edit_singleline(&mut self.gui_settings.search_query);

                    if ui.button("Clear").clicked() {
                        self.gui_settings.search_query.clear();
                        self.gui_settings.search_results = DrawableSearchResult::new();
                    }

                    ui.button("Search")
                });
                //DOWNLOAD SONG Code :
                if inner.inner.clicked() {
                    println!("Searching..");
                    let tidal_client = self.app.tidal_client.clone();
                    let search_query = self.gui_settings.search_query.clone();
                    let tx = self.gui_settings.event_manager.0.clone();
                    let ctx = ctx.clone();
                    tokio::spawn(async move {
                        let result: Result<SearchResult, tidal_rs::error::Error> = tidal_client
                            .search()
                            .all(&search_query, Some(20)).await;
                        if let Ok(search_result) = result {
                            let result = DrawableSearchResult::from_search_result(
                                &ctx,
                                &search_result
                            ).await;

                            let _ = tx.send(Event::SearchResult(result)).await;
                        }
                    });
                }

                if !self.gui_settings.search_results.is_empty() {
                    ui.horizontal(|ui| {
                        SearchType::search_types()
                            .iter()
                            .for_each(|x| {
                                ui.radio_value(
                                    &mut self.gui_settings.search_type,
                                    *x,
                                    x.to_string()
                                );
                            });
                    });

                    ScrollArea::new([false, true]).show(ui, |ui| {
                        match self.gui_settings.search_type {
                            SearchType::Artist => {
                                self.gui_settings.search_results.artist.iter().for_each(|artist| {
                                    ui.horizontal(|ui| {
                                        ui.add(
                                            Image::new(artist.get_texture()).fit_to_exact_size(
                                                Vec2 { x: 80.0, y: 80.0 }
                                            )
                                        );
                                        ui.label(format!("{}", artist.get_title()));
                                        if ui.button("Download").clicked() {
                                            let app = self.app.clone();
                                            let drawable_artist = artist.clone();

                                            tokio::spawn(async move {
                                                let quality = app.tidal_client
                                                .user()
                                                .get_current_account_highest_sound_quality().await
                                                .unwrap();

                                                let mut albums = app.tidal_client.media().get_artist_albums(drawable_artist.artist.id, None).await.unwrap_or(vec![]);
                                                let singles = app.tidal_client.media().get_artist_singles(drawable_artist.artist.id, None).await.unwrap_or(vec![]);

                                                albums.extend(singles.into_iter());

                                                for album in albums {
                                                    let _ = app.download_manager.enqueue_album(app.clone(), album, quality).await;
                                                }
                                            });
                                        }
                                    });
                                });
                            }
                            SearchType::Track => {
                                self.gui_settings.search_results.track.iter().for_each(|track| {
                                    ui.horizontal(|ui| {
                                        ui.add(
                                            Image::new(track.get_texture()).fit_to_exact_size(Vec2 {
                                                x: 80.0,
                                                y: 80.0,
                                            })
                                        );
                                        ui.label(track.get_title());
                                        if ui.button("Download").clicked() {
                                            let app = self.app.clone();
                                            let track = track.clone();
                                            tokio::spawn(async move {
                                                let quality = app.tidal_client
                                                    .user()
                                                    .get_current_account_highest_sound_quality().await
                                                    .unwrap();

                                                let _ = app.download_manager.enqueue_single(app.clone(), quality, track.track.clone()).await;
                                            });
                                        }
                                    });
                                });
                            }
                            SearchType::Album => {
                                self.gui_settings.search_results.album.iter().for_each(|album| {
                                    ui.horizontal(|ui| {
                                        ui.add(
                                            Image::new(album.get_texture()).fit_to_exact_size(Vec2 {
                                                x: 80.0,
                                                y: 80.0,
                                            })
                                        );
                                        ui.label(format!("{}", album.get_title()));
                                        if ui.button("Download").clicked() {
                                            let mut app = self.app.clone();
                                            let drawable_album = album.clone();

                                            tokio::spawn(async move {
                                                let quality = app.tidal_client
                                                    .user()
                                                    .get_current_account_highest_sound_quality().await
                                                    .unwrap();

                                                let _ = app.download_manager.enqueue_album(app.clone(), drawable_album.album.clone(), quality).await;
                                            });
                           
                                        }
                                    });
                                });
                            }
                            SearchType::Playlist => (),
                        }
                    });
                }

                //Display songs :

                let songs_array = self.app.database.songs().get_songs();
                let mut hasher = DefaultHasher::new();
                songs_array.hash(&mut hasher);
                let song_array_hash = hasher.finish();

                //check if the array has changed

        //        println!("InHash : {}, Current: {}", self.gui_settings.song_array.hash, song_array_hash);
                if self.gui_settings.song_array.hash != song_array_hash && self.gui_settings.song_array.created_at.elapsed().as_secs() > 1 && !self.gui_settings.requested_song_array {
                    let ctx = ctx.clone();
                    let tx = self.gui_settings.event_manager.0.clone();
                    let arr = songs_array.clone();
                    self.gui_settings.requested_song_array = true;
                    tokio::spawn(async move {
                        let song_array = DrawableSongArray::from_song_array(&ctx,arr).await;
                        let _  = tx.send(Event::SongArray(song_array)).await;
                    });
                }

                 ScrollArea::new([false, true]).show(ui, |ui| {
                    self.gui_settings.song_array.songs.iter().for_each(|song| {
                         ui.horizontal(|ui| {
                            ui.add(
                                Image::new(song.get_texture()).fit_to_exact_size(
                                    Vec2 { x: 80.0, y: 80.0 }
                                )
                            );
                            ui.label(format!("{}", song.get_title()));
                             if ui.button("Play").clicked() {
                        
                             }
                         });
                     });
                 });

                ui.horizontal(|ui| {
                    if ui.button("Logout").clicked() {
                    }
                });
            } else {
                ui.label("Not logged in");
            }
        });
    }
}
